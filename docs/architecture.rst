.. _architecture:

Architecture
************

.. contents:: Architecture
  :local:

The design of Kanister follows the operator pattern. This means
Kanister defines its own resources and interacts with those resources
through a controller. `This blog post
<https://www.redhat.com/en/blog/operators-over-easy-introduction-kubernetes-operators>`_ describes the
pattern in detail.

In particular, Kanister is composed of three main components: the
Controller and two Custom Resources - ActionSets and Blueprints.  The
diagram below illustrates their relationship and how they fit
together:

   .. image:: ./_static/kanister_workflow.png

Kanister Workflow
=================

As seen in the above diagram and described in detail below, all
Kanister operations are declarative and require an ActionSet to be
created by the user. Once the ActionSet is detected by the Kanister
controller, it examines the environment for Blueprint referenced in
the ActionSet (along with other required configuration). If all
requirements are satisfied, it will then use the discovered Blueprint
to complete the action (e.g., backup) specified in the
ActionSet. Finally, the original ActionSet will be updated by the
controller with status and other metadata generated by the action
execution.


Custom Resources
================

Users interact with Kanister through Kubernetes resources known as
CustomResources (CRs). When the controller starts, it creates the CR
definitions called CustomResourceDefinitions (CRDs).  `CRDs
<https://kubernetes.io/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>`_
were introduced in Kubernetes 1.7 and replaced TPRs. The lifecycle of these
objects can be managed entirely through kubectl. Kanister uses Kubernetes' code
generation tools to create go client libraries for its CRs.

The schemas of the Kanister CRDs can be found in `types.go
<https://github.com/kanisterio/kanister/tree/master/pkg/apis/cr/v1alpha1/types.go>`_

Blueprints
----------

Blueprint CRs are a set of instructions that tell the controller how to perform
actions on a specific application.

A Blueprint contains a field called ``Actions`` which is a mapping of Action Name
to ``BlueprintAction``.

The definition of a ``BlueprintAction`` is:

.. code-block:: go
  :linenos:

  // BlueprintAction describes the set of phases that constitute an action.
  type BlueprintAction struct {
      Name               string              `json:"name"`
      Kind               string              `json:"kind"`
      ConfigMapNames     []string            `json:"configMapNames"`
      SecretNames        []string            `json:"secretNames"`
      InputArtifactNames []string            `json:"inputArtifactNames"`
      OutputArtifacts    map[string]Artifact `json:"outputArtifacts"`
      Phases             []BlueprintPhase    `json:"phases"`
      DeferPhase         *BlueprintPhase     `json:"deferPhase,omitempty"`
  }

- ``Kind`` represents the type of Kubernetes object this BlueprintAction is written for.
  Specifying this is optional and going forward, if this is specified, Kanister will
  enforce that it matches the ``Object`` kind specified in an ActionSet referencing this
  BlueprintAction
- ``ConfigMapNames``, ``SecretNames``, ``InputArtifactNames`` are optional
  but, if specified, they list named parameters that must be included by
  the ``ActionSet``.
- ``OutputArtifacts`` is an optional map of rendered parameters made available
  to the ``BlueprintAction``.
- ``Phases`` is a required list of ``BlueprintPhases``. These phases are invoked
  in order when executing this Action.
- ``DeferPhase`` is an optional ``BlueprintPhase`` invoked after the
  execution of ``Phases`` defined above. A ``DeferPhase``, when specified,
  is executed regardless of the statuses of the ``Phases``.
  A ``DeferPhase`` can be used for cleanup operations at the end of an ``Action``.

.. code-block:: go
  :linenos:

  // BlueprintPhase is a an individual unit of execution.
  type BlueprintPhase struct {
      Func       string                     `json:"func"`
      Name       string                     `json:"name"`
      ObjectRefs map[string]ObjectReference `json:"objects"`
      Args       map[string]interface{}     `json:"args"`
  }

- ``Func`` is required as the name of a registered Kanister function.
  See :ref:`functions` for the list of  functions supported by the controller.
- ``Name`` is mostly cosmetic. It is useful in quickly identifying which
  phases the controller has finished executing.
- ``Object`` is a map of references to the Kubernetes objects on which
  the action will be performed.
- ``Args`` is a map of named arguments that the controller will pass to
  the Kanister function.
  String argument values can be templates that the controller will
  render using the template parameters. Each argument is rendered
  individually.

As a reference, below is an example of a BlueprintAction.

.. code-block:: yaml
  :linenos:

  actions:
    example-action:
      phases:
      - func: KubeExec
        name: examplePhase
        args:
          namespace: "{{ .Deployment.Namespace }}"
          pod: "{{ index .Deployment.Pods 0 }}"
          container: kanister-sidecar
          command:
            - bash
            - -c
            - |
              echo "Example Action"

.. _actionsets:

ActionSets
----------

Creating an ActionSet instructs the controller to run an action now.
The user specifies the runtime parameters inside the spec of the ActionSet.
Based on the parameters, the Controller populates the Status of the object,
executes the actions, and updates the ActionSet's status.

An ActionSetSpec contains a list of ActionSpecs. An ActionSpec is defined
as follows:

.. code-block:: go
 :linenos:

  // ActionSpec is the specification for a single Action.
  type ActionSpec struct {
      Name string                           `json:"name"`
      Object ObjectReference                `json:"object"`
      Blueprint string                      `json:"blueprint,omitempty"`
      Artifacts map[string]Artifact         `json:"artifacts,omitempty"`
      ConfigMaps map[string]ObjectReference `json:"configMaps"`
      Secrets map[string]ObjectReference    `json:"secrets"`
      Options map[string]string             `json:"options"`
      Profile *ObjectReference              `json:"profile"`
      PodOverride map[string]interface{}    `json:"podOverride,omitempty"`
  }

- ``Name`` is required and specifies the action in the Blueprint.
- ``Object`` is a required reference to the Kubernetes object on which
  the action will be performed.
- ``Blueprint`` is a required name of the Blueprint that contains the
   action to run.
- ``Artifacts`` are input Artifacts passed to the Blueprint. This must
  contain an Artifact for each name listed in the BlueprintAction's
  InputArtifacts.
- ``ConfigMaps`` and ``Secrets``, similar to ``Artifacts``, are a mappings of names
  specified in the Blueprint referencing the Kubernetes object to be used.
- ``Profile`` is a reference to a :ref:`Profile<profiles>` Kubernetes
  CustomResource that will be made available to the Blueprint.
- ``Options`` is used to specify additional values to be used in the Blueprint
- ``PodOverride`` is used to specify pod specs that will override default specs
  of the Pod created while executing functions like KubeTask, PrepareData, etc.

As a reference, below is an example of a ActionSpec.

.. code-block:: yaml
  :linenos:

  spec:
    actions:
    - name: example-action
      blueprint: example-blueprint
      object:
        kind: Deployment
        name: example-deployment
        namespace: example-namespace
      profile:
        apiVersion: v1alpha1
        kind: profile
        name: example-profile
        namespace: example-namespace

In addition to the Spec, an ActionSet also contains an ActionSetStatus
which mirrors the Spec, but contains the phases of execution, their
state, and the overall execution progress.

.. code-block:: go

  // ActionStatus is updated as we execute phases.
  type ActionStatus struct {
      Name string                   `json:"name"`
      Object ObjectReference        `json:"object"`
      Blueprint string              `json:"blueprint"`
      Phases []Phase                `json:"phases"`
      Artifacts map[string]Artifact `json:"artifacts"`
  }

Unlike in the ActionSpec, the Artifacts in the ActionStatus are the rendered
output artifacts from the Blueprint. These are rendered and populated once the action is complete.


Each phase in the ActionStatus phases list contains the phase name of the
Blueprint phase along with its state of execution and output.

.. code-block:: go

  // Phase is subcomponent of an action.
  type Phase struct {
      Name   string                 `json:"name"`
      State  State                  `json:"state"`
      Output map[string]interface{} `json:"output"`
  }


Deleting an ActionSet will cause the controller to delete the ActionSet,
which will stop the execution of the actions.

.. code-block:: bash

  $ kubectl --namespace kanister delete actionset s3backup-j4z6f
    actionset.cr.kanister.io "s3backup-j4z6f" deleted

.. note::
    Since ActionSets are ``Custom Resources``, Kubernetes allows users to delete them like any other API objects.
    Currently, *deleting* an ActionSet to stop execution is an **alpha** feature.

.. _profiles:

Profiles
--------

Profile CRs capture information about a location for data operation artifacts
and corresponding credentials that will be made available to a Blueprint.

The definition of a ``Profile`` is:

.. code-block:: go
  :linenos:

  // Profile
  type Profile struct {
    Location          Location   `json:"location"`
    Credential        Credential `json:"credential"`
    SkipSSLVerify     bool       `json:"skipSSLVerify"`
  }

- ``SkipSSLVerify`` is boolean and specifies whether skipping SkipSSLVerify
  verification is allowed when operating with the ``Location``. If omitted from
  a CR definition it default to ``false``
- ``Location`` is required and used to specify the location that the Blueprint
  can use. Currently, only s3 compliant locations are supported. If any of
  the sub-components are omitted, they will be treated as "".

  The definition of ``Location`` is as follows:

.. code-block:: go
  :linenos:

  // LocationType
  type LocationType string

  const (
    LocationTypeGCS         LocationType = "gcs"
    LocationTypeS3Compliant LocationType = "s3Compliant"
    LocationTypeAzure       LocationType = "azure"
  )

  // Location
  type Location struct {
    Type     LocationType `json:"type"`
    Bucket   string       `json:"bucket"`
    Endpoint string       `json:"endpoint"`
    Prefix   string       `json:"prefix"`
    Region   string       `json:"region"`
  }

- ``Credential`` is required and used to specify the credentials associated with
  the ``Location``. Currently, only key pair s3, gcs and azure location credentials are
  supported.

  The definition of ``Credential`` is as follows:

.. code-block:: go
  :linenos:

  // CredentialType
  type CredentialType string

  const (
    CredentialTypeKeyPair CredentialType = "keyPair"
  )

  // Credential
  type Credential struct {
    Type    CredentialType `json:"type"`
    KeyPair *KeyPair       `json:"keyPair"`
  }

  // KeyPair
  type KeyPair struct {
    IDField     string          `json:"idField"`
    SecretField string          `json:"secretField"`
    Secret      ObjectReference `json:"secret"`
  }

- ``IDField`` and ``SecretField`` are required and specify the corresponding
  keys in the secret under which the ``KeyPair`` credentials are stored.
- ``Secret`` is required reference to a Kubernetes Secret object storing the
  ``KeyPair`` credentials.

As a reference, below is an example of a Profile and the corresponding secret.

.. code-block:: yaml
  :linenos:

  apiVersion: cr.kanister.io/v1alpha1
  kind: Profile
  metadata:
    name: example-profile
    namespace: example-namespace
  location:
    type: s3Compliant
    bucket: example-bucket
    endpoint: <endpoint URL>:<port>
    prefix: ""
    region: ""
  credential:
    type: keyPair
    keyPair:
      idField: example_key_id
      secretField: example_secret_access_key
      secret:
        apiVersion: v1
        kind: Secret
        name: example-secret
        namespace: example-namespace
  skipSSLVerify: true
  ---
  apiVersion: v1
  kind: Secret
  type: Opaque
  metadata:
    name: example-secret
    namespace: example-namespace
  data:
    example_key_id: <access key>
    example_secret_access_key: <access secret>

RepositoryServers
-----------------

RepositoryServer CR is required by kanister controller to start
a kopia repository server. The CR has list of parameters to configure
kopia repository server.

.. note::
    Secrets referenced in the CR should be created in the format referenced
    in the :ref:`Repository Server Secrets<repositoryserversecrets>` section


The definition of ``Repository Server`` is:

.. code-block:: go
  :linenos:

  // RepositoryServer manages the lifecycle of Kopia Repository Server within a Pod
  type RepositoryServer struct {
	  metav1.TypeMeta   `json:",inline"`
	  metav1.ObjectMeta `json:"metadata,omitempty"`
	  Spec RepositoryServerSpec `json:"spec"`
	  Status RepositoryServerStatus `json:"status"`
  }

  Repository Server ``Spec`` field is defined as follows:

.. code-block:: go
  :linenos:

  type RepositoryServerSpec struct {
	  Storage Storage `json:"storage"`
	  Repository Repository `json:"repository"`
	  Server Server `json:"server"`
  }

- ``Storage`` field in the ``RepositoryServerSpec`` contains the location
  details where the kopia repository is created

.. code-block:: go
  :linenos:

  type Storage struct {
  	SecretRef corev1.SecretReference `json:"secretRef"`
  	CredentialSecretRef corev1.SecretReference `json:"credentialSecretRef"`
  }

^ ``SecretRef`` and ``CredentialSecretRef`` are the references to location
  secrets
  
- ``Repository`` field in CR ``spec`` has details to connect to kopia repository created 
  in the above location storage

.. code-block:: go
  :linenos:

  type Repository struct {
	  RootPath string `json:"rootPath"`
	  Username string `json:"username"`
	  Hostname string `json:"hostname"`
	  PasswordSecretRef corev1.SecretReference `json:"passwordSecretRef"`
  }

Kopia identifies users by ``username@hostname`` and uses the values
specified when establishing connection to the repository to identify
backups created in the session.

^ ``RootPath`` is the path for the kopia repository. It is the subpath within
the path prefix specified in storage location
^ ``Username`` is an optional field used to override the default username while
connecting to kopia repository
^ ``Hostname`` is an optional field used to override the default hostname while
connecting to kopia repository
^ ``PasswordSecretRef`` is the reference to the secret containing password to
connect to kopia repository


- ``Server`` field in the CR spec has references to all the secrets
  required to start the kopia repository server

.. code-block:: go
  :linenos:

  type Server struct {
	  UserAccess UserAccess `json:"userAccess"`
	  AdminSecretRef corev1.SecretReference `json:"adminSecretRef"`
	  TLSSecretRef corev1.SecretReference `json:"tlsSecretRef"`
  }

^ ``AdminSecretRef`` is a secret reference containing admin credentials
  required to start the kopia repository server
^ ``TLSSecretRef`` is a TLS secret reference for kopia client and server communication
^ ``UserAccess`` contains username and password secret reference required
  for creating kopia respository server users.
  
.. code-block:: go
  :linenos:

  type UserAccess struct {
	  UserAccessSecretRef corev1.SecretReference `json:"userAccessSecretRef"`
	  Username string `json:"username"`
  }


- ``Status`` field in ``RepositoryServer`` CR is used by kanister controller
  to propogate server's status to the client. It is defined as:

.. code-block:: go
  :linenos:

  type RepositoryServerStatus struct {
	  Conditions []Condition              `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type"`
	  ServerInfo ServerInfo               `json:"serverInfo,omitempty"`
	  Progress   RepositoryServerProgress `json:"progress"`
  }
- ``Progress`` is populated by controller with 3 values

  ^ ``ServerReady`` represents the ready state of the repository server and
  the pod which runs the proxy server
	^ ``ServerStopped`` represents that the controller got an error while
  starting the repository server
	^ ``ServerPending`` represents that repository server is yet to be started completely

- ``ServerInfo`` is populated by the kanister controller with
the server details that client requires to connect to the server.

.. code-block:: go
  :linenos:

  type ServerInfo struct {
	  PodName     string `json:"podName,omitempty"`
	  ServiceName string `json:"serviceName,omitempty"`
  }

^ ``PodName`` is the name of pod created by controller for kopia repository server
^ ``ServiceName`` is the name of the kubernetes service created by the controller
which contains the connection details for repository server


As a reference, below is an example of a Repository Server

.. code-block:: yaml
  :linenos:

  apiVersion: cr.kanister.io/v1alpha1
  kind: RepositoryServer
  metadata:
    name: kopia-repo-server-monitoring
    namespace: <kanister-namespace>
  spec:
    storage:
      secretRef:
        name: <location-secret>
        namespace: <kanister-namespace>
      credentialSecretRef:
        name: <credentials-secret>
        namespace: <kanister-namespace>
    repository:
      rootPath: /repo/monitoring
      passwordSecretRef:
        name: <repo-pass-secret>
        namespace: <kanister-namespace>
      username: <username-to-connect-repository>
      hostname: <hostname-to-connect-repository>
    server:
      adminSecretRef:
        name: <server-admin-username-secret>
        namespace: kanister
      tlsSecretRef:
        name: <server-tls-cert-secret>
        namespace: kanister
      userAccess:
        userAccessSecretRef:
          name: <server-user-password-secret>
          namespace: kanister
        username: <server-user>

RepositoryServerSecrets
=========================

Kanister controller needs the following secrets to be created for starting the kopia
repository server successfully. The secrets are referenced in the ``RepositoryServer``
CR as described in  :ref:`RepositoryServer<repositoryservers>`

Controller
==========

The Kanister controller is a Kubernetes Deployment and is installed easily using
``kubectl``. See :ref:`install` for more information on deploying the controller.

Execution Walkthrough
---------------------

The controller watches for new/updated ActionSets in the same namespace in which
it is deployed. When it sees an ActionSet with a nil status field, it
immediately initializes the ActionSet's status to the Pending State. The status is
also prepopulated with the pending phases.

Execution begins by resolving all the :ref:`templates`. If any required
object references or artifacts are missing from the ActionSet, the ActionSet
status is marked as failed. Otherwise, the template params are used to render the
output Artifacts, and then the args in the Blueprint.

For each action, all phases are executed in-order. The rendered args are
passed to :ref:`templates` which correspond to a single phase. When a phase
completes, the status of the phase is updated. If any single phase fails, the
entire ActionSet is marked as failed.  Upon failure, the controller ceases
execution of the ActionSet.

Within an ActionSet, individual Actions are run in parallel.

Currently the user is responsible for cleaning up ActionSets once they complete.

During execution, Kanister controller emits events to the respective ActionSets.
In above example, the execution transitions of ActionSet ``s3backup-j4z6f`` can be
seen by using the following command:

.. code-block:: bash

  $ kubectl --namespace kanister describe actionset s3backup-j4z6f
  Events:
    Type    Reason           Age   From                 Message
    ----    ------           ----  ----                 -------
    Normal  Started Action   23s   Kanister Controller  Executing action backup
    Normal  Started Phase    23s   Kanister Controller  Executing phase backupToS3
    Normal  Update Complete  19s   Kanister Controller  Updated ActionSet 's3backup-j4z6f' Status->complete
    Normal  Ended Phase      19s   Kanister Controller  Completed phase backupToS3
